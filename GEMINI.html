<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Survival Builder 3D | Fixed</title>
  <style>
    :root {
      --primary: #00f2ff;
      --danger: #ff2a2a;
      --success: #00ff88;
      --wood: #ffaa00;
      --hud-bg: rgba(10, 15, 20, 0.85);
    }
    body { 
      margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; 
      background: #000; color: #fff; user-select: none; 
    }
    
    /* HUD LAYOUT */
    #ui-layer {
      position: fixed; inset: 0; pointer-events: none; z-index: 10;
      display: flex; flex-direction: column; justify-content: space-between;
      padding: 20px;
    }

    .top-bar { display: flex; justify-content: space-between; align-items: flex-start; }
    
    .card {
      background: var(--hud-bg); backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1); border-radius: 12px;
      padding: 15px 20px; min-width: 160px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      transition: transform 0.2s;
    }
    
    /* HP BAR */
    .hp-wrap { width: 100%; height: 12px; background: #333; margin-top: 8px; border-radius: 6px; overflow: hidden; }
    #hp-fill { width: 100%; height: 100%; background: var(--success); transition: width 0.1s; }
    
    /* BOTTOM BAR */
    .bottom-bar { 
      display: flex; gap: 15px; justify-content: center; align-items: flex-end; 
      margin-bottom: 20px;
    }
    
    .skill-box {
      background: var(--hud-bg); border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px; padding: 10px 15px; text-align: center;
      min-width: 100px; position: relative;
    }
    .skill-key {
      position: absolute; top: -10px; left: 50%; transform: translateX(-50%);
      background: #fff; color: #000; font-weight: bold; font-size: 12px;
      padding: 2px 6px; border-radius: 4px; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    .active-skill { border-color: var(--primary); box-shadow: 0 0 15px var(--primary); }
    
    /* Mode Indicator */
    #mode-pill {
      background: var(--primary); color: #000; padding: 12px 40px;
      border-radius: 30px; font-weight: 900; letter-spacing: 2px;
      text-transform: uppercase; font-size: 18px;
      box-shadow: 0 0 20px var(--primary);
    }

    /* Crosshair */
    #reticle {
      position: fixed; top: 50%; left: 50%; width: 6px; height: 6px;
      background: #fff; border-radius: 50%; transform: translate(-50%, -50%);
      pointer-events: none; z-index: 9; box-shadow: 0 0 0 2px rgba(0,0,0,0.5);
    }

    /* SCREENS */
    .fullscreen-overlay {
      position: fixed; inset: 0; background: rgba(5,5,10,0.95);
      z-index: 100; display: flex; flex-direction: column; 
      align-items: center; justify-content: center; pointer-events: auto;
    }
    h1 { font-size: 60px; margin: 0; color: #fff; text-transform: uppercase; letter-spacing: -2px; }
    h1 span { color: var(--primary); }
    .btn {
      margin-top: 30px; padding: 20px 60px; font-size: 24px; font-weight: bold;
      background: var(--primary); border: none; border-radius: 8px; cursor: pointer;
      transition: 0.2s; color: #000;
    }
    .btn:hover { transform: scale(1.05); filter: brightness(1.1); }

    /* DAMAGE FX */
    #damage-overlay {
      position: fixed; inset: 0; pointer-events: none; z-index: 50;
      background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.6));
      opacity: 0; transition: opacity 0.1s;
    }
    #flash-overlay {
      position: fixed; inset: 0; pointer-events: none; z-index: 51;
      background: white; opacity: 0; transition: opacity 0.5s;
    }
    
    #hints {
        position: fixed; bottom: 10px; left: 15px; color: rgba(255,255,255,0.4); font-size: 12px;
    }
  </style>
</head>
<body>

  <div id="ui-layer">
    <div class="top-bar">
      <div class="card">
        <div style="font-size:12px; color:var(--wood); font-weight:bold;">RECURSOS</div>
        <div style="font-size:24px; font-weight:900;">游뿻 <span id="wood-val">0</span></div>
        <div class="hp-wrap"><div id="hp-fill"></div></div>
        <div style="font-size:12px; margin-top:5px; display:flex; justify-content:space-between;">
            <span>VIDA</span> <span id="hp-text">100%</span>
        </div>
      </div>
      
      <div class="card" style="text-align:center;">
        <div style="font-size:12px; opacity:0.6;">TEMPO SOBREVIVIDO</div>
        <div id="timer" style="font-size:32px; font-weight:800; font-variant-numeric: tabular-nums;">00:00</div>
      </div>

      <div class="card" style="border-color: var(--success);">
        <div style="font-size:12px; color:var(--success); font-weight:bold;">ESTAT칈STICAS</div>
        <div>Recorde: <span id="record-val">00:00</span></div>
        <div>Inimigos: <span id="kill-val">0</span></div>
      </div>
    </div>

    <div class="bottom-bar">
      <div class="skill-box" id="box-bomb">
        <div class="skill-key">Q</div>
        <div style="color:yellow; font-weight:bold;">BOMBA</div>
        <div id="bomb-count" style="font-size:20px;">2</div>
      </div>

      <div id="mode-pill">COMBATE</div>

      <div class="skill-box" id="box-shield">
        <div class="skill-key">R</div>
        <div style="color:cyan; font-weight:bold;">ESCUDO</div>
        <div id="shield-count" style="font-size:20px;">1</div>
      </div>
    </div>
  </div>

  <div id="reticle"></div>
  <div id="damage-overlay"></div>
  <div id="flash-overlay"></div>
  <div id="hints">WASD: Mover | SPACE: Pulo | E: Construir | C: Ombro | F: Girar Parede</div>

  <div id="start-menu" class="fullscreen-overlay">
    <h1>Survival <span>Builder</span></h1>
    <p style="opacity:0.7">Construa sua base. Sobreviva  noite.</p>
    <button class="btn" onclick="startGame()">INICIAR</button>
  </div>

  <div id="death-menu" class="fullscreen-overlay" style="display:none;">
    <h1 style="color: var(--danger)">GAME OVER</h1>
    <p style="font-size:24px;">Voc칡 sobreviveu por: <span id="final-time">00:00</span></p>
    <button class="btn" onclick="startGame()">TENTAR DE NOVO</button>
  </div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // --- CONFIGURA칂칏ES GERAIS ---
    const CFG = {
      speed: 8.5,
      jump: 12,
      gravity: 25,
      mouseSens: 0.003,
      wallDist: 6,     // Dist칙ncia que a parede aparece na frente
      wallCost: 2,
      wallHP: 600,
      enemySpeed: 3.5,
      enemyDmg: 15,
      bombTime: 8,     // Dura칞칚o do efeito da bomba
      shieldTime: 15,  // Dura칞칚o do escudo
      shieldCD: 30,    // Cooldown do escudo
      woodPerTree: 5
    };

    // --- VARI츼VEIS DO SISTEMA ---
    let scene, camera, renderer, clock;
    let isRunning = false, isBuildMode = false;
    let yaw = 0, pitch = 0;
    let manualRot = false, manualRot90 = false;
    let shoulder = 1; // 1 = direita, -1 = esquerda

    // --- ESTADO DO JOGO ---
    // CORRE칂츾O 1: Adicionei stats aqui para n칚o dar erro no in칤cio
    const player = {
      pos: new THREE.Vector3(0, 0, 0),
      vel: new THREE.Vector3(0, 0, 0),
      hp: 100,
      wood: 0,
      bombs: 2,
      shields: 1,
      stats: { kills: 0 },
      timers: { shield: 0, shieldCD: 0, bomb: 0, start: 0 },
      onGround: false
    };

    const entities = {
      walls: [],
      enemies: [],
      bullets: [],
      trees: [],
      drops: []
    };

    // Grupos para Three.js
    const groups = {
      world: new THREE.Group(),
      player: new THREE.Group()
    };
    
    // Partes do Player (para anima칞칚o)
    let gunMesh, shieldMesh;

    // --- INICIALIZA칂츾O ---
    function init() {
      // Cena
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x11151c); // Azul noturno escuro
      scene.fog = new THREE.Fog(0x11151c, 20, 80);

      // C칙mera
      camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 500);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      clock = new THREE.Clock();

      // Luzes
      const ambient = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambient);

      const sun = new THREE.DirectionalLight(0xaaddff, 1.2);
      sun.position.set(30, 50, 20);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.left = -50;
      sun.shadow.camera.right = 50;
      sun.shadow.camera.top = 50;
      sun.shadow.camera.bottom = -50;
      scene.add(sun);

      // Ch칚o
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(150, 150),
        new THREE.MeshStandardMaterial({ color: 0x1a202c, roughness: 0.8 })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Grid
      const grid = new THREE.GridHelper(150, 75, 0x334155, 0x2d3748);
      grid.position.y = 0.02;
      scene.add(grid);

      // Player Visuals
      createPlayer();
      scene.add(groups.player);

      // Ghost Wall (Preview da constru칞칚o)
      createGhostWall();

      // Inputs
      setupInputs();

      // Update UI inicial
      updateUI();
      
      // Loop
      animate();
    }

    function createPlayer() {
      // Corpo
      const body = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.4, 1, 4, 8),
        new THREE.MeshStandardMaterial({ color: 0x00f2ff })
      );
      body.position.y = 0.9;
      body.castShadow = true;
      groups.player.add(body);

      // Cabe칞a
      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.25),
        new THREE.MeshStandardMaterial({ color: 0x00f2ff })
      );
      head.position.y = 1.6;
      groups.player.add(head);

      // Arma
      gunMesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.15, 0.6),
        new THREE.MeshStandardMaterial({ color: 0x333 })
      );
      gunMesh.position.set(0.4, 1.3, 0.3);
      gunMesh.castShadow = true;
      groups.player.add(gunMesh);

      // Escudo (Visual)
      shieldMesh = new THREE.Mesh(
        new THREE.SphereGeometry(1.2, 32, 32),
        new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.2, wireframe: true })
      );
      shieldMesh.position.y = 1;
      shieldMesh.visible = false;
      groups.player.add(shieldMesh);
    }

    // --- L칍GICA DE CONSTRU칂츾O ---
    let ghostWall;
    
    function createGhostWall() {
      ghostWall = new THREE.Mesh(
        new THREE.BoxGeometry(4, 2.5, 0.3),
        new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.4 })
      );
      scene.add(ghostWall);
    }

    function updateGhost() {
      if (!isBuildMode) {
        ghostWall.visible = false;
        return;
      }

      // Calcula posi칞칚o baseada na dire칞칚o da c칙mera + dist칙ncia fixa
      const camDir = new THREE.Vector3();
      camera.getWorldDirection(camDir);
      camDir.y = 0; // Trava no plano horizontal
      camDir.normalize();

      const targetPos = player.pos.clone().add(camDir.multiplyScalar(CFG.wallDist));

      // Snap to Grid (Arredonda para n칰meros pares)
      const gx = Math.round(targetPos.x / 2) * 2;
      const gz = Math.round(targetPos.z / 2) * 2;

      ghostWall.position.set(gx, 1.25, gz);

      // Rota칞칚o Autom치tica (90 graus dependendo de onde olha)
      const lookX = Math.abs(camDir.x);
      const lookZ = Math.abs(camDir.z);
      
      let angle = (lookX > lookZ) ? Math.PI/2 : 0;
      if (manualRot) angle = manualRot90 ? Math.PI/2 : 0;
      
      ghostWall.rotation.y = angle;
      ghostWall.visible = true;

      // Cor: Verde se tem madeira, Vermelho se n칚o
      const canAfford = player.wood >= CFG.wallCost;
      const distOk = player.pos.distanceTo(ghostWall.position) > 1.5; // N칚o construir dentro de si
      ghostWall.material.color.setHex((canAfford && distOk) ? 0x00ff00 : 0xff0000);
    }

    function buildWall() {
      if (!ghostWall.visible || ghostWall.material.color.getHex() === 0xff0000) return;

      player.wood -= CFG.wallCost;

      const wall = new THREE.Mesh(
        new THREE.BoxGeometry(4, 2.5, 0.3),
        new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.9 })
      );
      wall.position.copy(ghostWall.position);
      wall.rotation.copy(ghostWall.rotation);
      wall.castShadow = true;
      wall.receiveShadow = true;
      wall.userData = { hp: CFG.wallHP, maxHP: CFG.wallHP };

      // Barra de HP na parede
      const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 10;
      const ctx = canvas.getContext('2d');
      const tex = new THREE.CanvasTexture(canvas);
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
      sprite.position.y = 1.6;
      sprite.scale.set(2, 0.3, 1);
      wall.add(sprite);
      wall.userData.sprite = { mesh: sprite, ctx: ctx, tex: tex, canvas: canvas };
      updateWallHP(wall);

      scene.add(wall);
      entities.walls.push(wall);
    }

    function updateWallHP(wall) {
      const { ctx, canvas, tex, mesh } = wall.userData.sprite;
      const pct = wall.userData.hp / wall.userData.maxHP;
      
      // Se estiver 100%, esconde a barra
      if (pct >= 0.99) { mesh.visible = false; return; }
      mesh.visible = true;

      ctx.fillStyle = '#333';
      ctx.fillRect(0,0,64,10);
      ctx.fillStyle = pct > 0.5 ? '#0f0' : '#f00';
      ctx.fillRect(1,1, 62 * pct, 8);
      tex.needsUpdate = true;
    }

    // --- GAMEPLAY LOOP ---
    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.1);
      const now = clock.getElapsedTime();

      if (isRunning) {
        // 1. Movimenta칞칚o F칤sica
        updatePlayerMove(dt);
        
        // 2. C칙mera Ombro
        updateCamera(dt);

        // 3. Entidades
        // CORRE칂츾O 2: Nome da fun칞칚o corrigido de updateConstruction para updateGhost
        updateGhost(); 
        updateBullets(dt);
        updateEnemies(dt, now);
        updatePowerups(dt, now);

        // 4. UI Update
        updateUI(now);

        // 5. Spawners
        const difficulty = (now - player.timers.start) / 60; // Dificuldade aumenta com o tempo
        if (Math.random() < (0.01 + difficulty * 0.01)) spawnEnemy();
        if (Math.random() < 0.002) spawnDrop();

      } else {
        // C칙mera girando no menu
        const t = now * 0.2;
        camera.position.set(Math.sin(t)*15, 8, Math.cos(t)*15);
        camera.lookAt(0, 0, 0);
      }

      renderer.render(scene, camera);
    }

    // --- F칈SICA E MOVIMENTO ---
    const keys = {};
    function updatePlayerMove(dt) {
      // Vetores de dire칞칚o baseados na c칙mera
      const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
      const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);

      const input = new THREE.Vector3();
      if (keys['KeyW']) input.add(forward);
      if (keys['KeyS']) input.sub(forward);
      if (keys['KeyA']) input.sub(right);
      if (keys['KeyD']) input.add(right);

      if (input.lengthSq() > 0) input.normalize();

      // Acelera칞칚o e Fric칞칚o
      player.vel.x += (input.x * CFG.speed - player.vel.x) * 10 * dt;
      player.vel.z += (input.z * CFG.speed - player.vel.z) * 10 * dt;

      // Gravidade
      if (player.pos.y > 0) {
        player.vel.y -= CFG.gravity * dt;
        player.onGround = false;
      } else {
        player.vel.y = 0;
        player.pos.y = 0;
        player.onGround = true;
        if (keys['Space']) player.vel.y = CFG.jump;
      }

      // Aplica velocidade
      player.pos.add(player.vel.clone().multiplyScalar(dt));

      // Limites do mapa
      player.pos.x = Math.max(-70, Math.min(70, player.pos.x));
      player.pos.z = Math.max(-70, Math.min(70, player.pos.z));

      // Colis칚o Simples Player x Parede
      entities.walls.forEach(w => {
        if (player.pos.distanceTo(w.position) < 2.2) {
            const push = player.pos.clone().sub(w.position).normalize().multiplyScalar(0.1);
            push.y = 0;
            player.pos.add(push);
        }
      });
      
      // Coleta de Madeira
      entities.trees.forEach((t, i) => {
          if (player.pos.distanceTo(t.position) < 2) {
              player.wood += CFG.woodPerTree;
              scene.remove(t);
              entities.trees.splice(i, 1);
              setTimeout(spawnTree, 5000); // Respawn 치rvore
          }
      });

      // Sync Gr치fico
      groups.player.position.copy(player.pos);
      groups.player.rotation.y = yaw;
      
      // Anima칞칚o da arma (Bobbing)
      const moving = input.lengthSq() > 0;
      gunMesh.position.z = 0.3 + (moving ? Math.sin(clock.getElapsedTime()*15)*0.05 : 0);
      gunMesh.rotation.x = pitch;
    }

    function updateCamera(dt) {
      // Posi칞칚o Alvo (Ombro)
      const offset = new THREE.Vector3(1.5 * shoulder, 2.2, 5);
      offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
      
      const target = player.pos.clone().add(offset);
      target.y += pitch * 2; // Olha pra cima/baixo
      
      // Impede c칙mera de entrar no ch칚o
      if (target.y < 0.5) target.y = 0.5;

      camera.position.lerp(target, 0.2); // Smooth follow

      // LookAt Target (na frente do player)
      const lookT = player.pos.clone();
      lookT.y = 1.6 + pitch * 2; // Altura cabe칞a
      const fwd = new THREE.Vector3(0, 0, -10).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
      camera.lookAt(lookT.add(fwd));
    }

    // --- COMBATE ---
    function shoot() {
      const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.15),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
      );
      // Sai da arma
      bullet.position.copy(gunMesh.getWorldPosition(new THREE.Vector3()));
      
      // Raycast do centro da tela para precis칚o
      const ray = new THREE.Raycaster();
      ray.setFromCamera(new THREE.Vector2(0,0), camera);
      const target = ray.ray.at(50, new THREE.Vector3());
      
      const dir = new THREE.Vector3().subVectors(target, bullet.position).normalize();
      
      bullet.userData = { vel: dir.multiplyScalar(50), life: 2 }; // Velocidade 50
      scene.add(bullet);
      entities.bullets.push(bullet);

      // Recuo visual
      gunMesh.position.z += 0.2;
    }

    function updateBullets(dt) {
      for (let i = entities.bullets.length - 1; i >= 0; i--) {
        const b = entities.bullets[i];
        b.position.add(b.userData.vel.clone().multiplyScalar(dt));
        b.userData.life -= dt;

        let hit = false;
        
        // Colis칚o com inimigos
        for (let j = entities.enemies.length - 1; j >= 0; j--) {
          const e = entities.enemies[j];
          if (b.position.distanceTo(e.position) < 1) {
             e.userData.hp--;
             e.material.color.setHex(0xffffff); // Flash hit
             setTimeout(() => e.material.color.setHex(0xff0044), 50);
             
             if (e.userData.hp <= 0) {
                 scene.remove(e);
                 entities.enemies.splice(j, 1);
                 player.stats.kills++;
             }
             hit = true; break;
          }
        }

        if (hit || b.userData.life <= 0) {
            scene.remove(b);
            entities.bullets.splice(i, 1);
        }
      }
    }

    function updateEnemies(dt, now) {
      // Efeito BOMBA (Congela e mata se ativo)
      if (now < player.timers.bomb) return;

      entities.enemies.forEach(e => {
        const dist = e.position.distanceTo(player.pos);
        
        // Movimento
        const dir = player.pos.clone().sub(e.position).normalize();
        
        // Colis칚o com Paredes
        let blocked = false;
        entities.walls.forEach(w => {
            if (e.position.distanceTo(w.position) < 2.5) {
                blocked = true;
                w.userData.hp -= CFG.enemyDmg * dt;
                updateWallHP(w);
                if (w.userData.hp <= 0) {
                    scene.remove(w);
                    entities.walls = entities.walls.filter(xw => xw !== w);
                }
            }
        });

        if (!blocked) {
            e.position.add(dir.multiplyScalar(CFG.enemySpeed * dt));
            e.lookAt(player.pos);
        }

        // Dano ao Player
        if (dist < 1.2) {
            // Se tiver escudo ativo, n칚o toma dano
            if (now < player.timers.shield) return;

            player.hp -= CFG.enemyDmg * dt;
            
            // Efeito visual de dano
            const op = document.getElementById('damage-overlay');
            op.style.opacity = 0.8;
            setTimeout(() => op.style.opacity = 0, 100);

            if (player.hp <= 0) gameOver();
        }
      });
    }

    function spawnEnemy() {
      if (clock.getElapsedTime() < player.timers.bomb) return;
      
      const enemy = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.5, 1, 4, 8),
        new THREE.MeshStandardMaterial({ color: 0xff0044 })
      );
      // Spawn longe (c칤rculo)
      const ang = Math.random() * Math.PI * 2;
      enemy.position.set(Math.cos(ang)*50, 1, Math.sin(ang)*50);
      enemy.userData = { hp: 3 };
      scene.add(enemy);
      entities.enemies.push(enemy);
    }

    function spawnTree() {
      const tree = new THREE.Group();
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 2), new THREE.MeshStandardMaterial({ color: 0x5c4033 }));
      const leaves = new THREE.Mesh(new THREE.ConeGeometry(2, 4, 8), new THREE.MeshStandardMaterial({ color: 0x228b22 }));
      trunk.position.y = 1; leaves.position.y = 3;
      tree.add(trunk, leaves);
      
      const x = (Math.random()-0.5)*120;
      const z = (Math.random()-0.5)*120;
      if (Math.abs(x) < 10 && Math.abs(z) < 10) return; // Longe do spawn
      
      tree.position.set(x, 0, z);
      scene.add(tree);
      entities.trees.push(tree);
    }

    // --- POWERUPS & DROPS ---
    function spawnDrop() {
       const type = Math.random() > 0.5 ? 'bomb' : 'shield';
       const color = type === 'bomb' ? 0xffff00 : 0x00ffff;
       const drop = new THREE.Mesh(new THREE.OctahedronGeometry(0.5), new THREE.MeshBasicMaterial({ color: color }));
       drop.position.set((Math.random()-0.5)*60, 1, (Math.random()-0.5)*60);
       drop.userData = { type: type, yBase: 1, offset: Math.random()*10 };
       
       // Glow
       const light = new THREE.PointLight(color, 1, 5);
       drop.add(light);

       scene.add(drop);
       entities.drops.push(drop);
    }

    function updatePowerups(dt, now) {
       for (let i = entities.drops.length -1; i>=0; i--) {
           const d = entities.drops[i];
           d.rotation.y += dt;
           d.position.y = 1 + Math.sin(now * 3 + d.userData.offset) * 0.3;
           
           if (player.pos.distanceTo(d.position) < 1.5) {
               if (d.userData.type === 'bomb') player.bombs++;
               else player.shields++;
               scene.remove(d);
               entities.drops.splice(i, 1);
           }
       }
    }

    function useBomb() {
        if (player.bombs > 0 && clock.getElapsedTime() > player.timers.bomb) {
            player.bombs--;
            player.timers.bomb = clock.getElapsedTime() + CFG.bombTime;
            
            // Flash Branco
            const f = document.getElementById('flash-overlay');
            f.style.opacity = 1;
            setTimeout(() => f.style.opacity = 0, 500);

            // Matar inimigos
            entities.enemies.forEach(e => scene.remove(e));
            entities.enemies = [];
        }
    }

    function useShield() {
        if (player.shields > 0 && clock.getElapsedTime() > player.timers.shieldCD) {
            player.shields--;
            const now = clock.getElapsedTime();
            player.timers.shield = now + CFG.shieldTime;
            player.timers.shieldCD = now + CFG.shieldTime + CFG.shieldCD;
            shieldMesh.visible = true;
        }
    }

    // --- INPUTS & UI ---
    function setupInputs() {
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'KeyE') {
                isBuildMode = !isBuildMode;
                document.getElementById('mode-pill').innerText = isBuildMode ? "CONSTRU칂츾O" : "COMBATE";
                document.getElementById('mode-pill').style.background = isBuildMode ? "var(--wood)" : "var(--primary)";
            }
            if (e.code === 'KeyF') { manualRot = true; manualRot90 = !manualRot90; }
            if (e.code === 'KeyC') shoulder *= -1;
            if (e.code === 'KeyQ') useBomb();
            if (e.code === 'KeyR') useShield();
        });
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement) {
                yaw -= e.movementX * CFG.mouseSens;
                pitch -= e.movementY * CFG.mouseSens;
                pitch = Math.max(-1.4, Math.min(1.4, pitch)); // Limita olhar cima/baixo
            }
        });
        
        document.addEventListener('mousedown', (e) => {
            if (!isRunning) return;
            if (!document.pointerLockElement) { document.body.requestPointerLock(); return; }
            if (e.button === 0) {
                if (isBuildMode) buildWall(); else shoot();
            }
        });
    }

    function updateUI() {
        const now = clock.getElapsedTime();
        
        // Stats
        document.getElementById('wood-val').innerText = player.wood;
        document.getElementById('hp-fill').style.width = Math.max(0, player.hp) + '%';
        document.getElementById('hp-text').innerText = Math.ceil(player.hp) + '%';
        
        // Check for stats to avoid crash
        if (player.stats) {
            document.getElementById('kill-val').innerText = player.stats.kills || 0;
        }
        
        // Bomb
        const bombOn = now < player.timers.bomb;
        document.getElementById('bomb-count').innerText = bombOn ? "ATIVO" : player.bombs;
        document.getElementById('box-bomb').className = bombOn ? "skill-box active-skill" : "skill-box";

        // Shield
        const shieldOn = now < player.timers.shield;
        if (shieldOn) {
             document.getElementById('shield-count').innerText = "ATIVO " + Math.ceil(player.timers.shield - now);
             document.getElementById('box-shield').className = "skill-box active-skill";
             shieldMesh.visible = true;
        } else {
             shieldMesh.visible = false;
             if (now < player.timers.shieldCD) {
                 document.getElementById('shield-count').innerText = "CD " + Math.ceil(player.timers.shieldCD - now);
                 document.getElementById('box-shield').style.opacity = 0.5;
             } else {
                 document.getElementById('shield-count').innerText = player.shields;
                 document.getElementById('box-shield').style.opacity = 1;
             }
             document.getElementById('box-shield').className = "skill-box";
        }

        // Timer
        const t = now - player.timers.start;
        const m = Math.floor(t / 60).toString().padStart(2, '0');
        const s = Math.floor(t % 60).toString().padStart(2, '0');
        document.getElementById('timer').innerText = `${m}:${s}`;
    }

    window.startGame = function() {
        document.getElementById('start-menu').style.display = 'none';
        document.getElementById('death-menu').style.display = 'none';
        
        // Reset Logic
        player.hp = 100; player.wood = 0; player.bombs = 2; player.shields = 1;
        player.pos.set(0,0,0); player.vel.set(0,0,0);
        player.timers.start = clock.getElapsedTime();
        player.timers.bomb = 0; player.timers.shield = 0; player.timers.shieldCD = 0;
        player.stats = { kills: 0 };
        
        // Clear Entities
        entities.enemies.forEach(x=>scene.remove(x)); entities.enemies = [];
        entities.bullets.forEach(x=>scene.remove(x)); entities.bullets = [];
        entities.walls.forEach(x=>scene.remove(x)); entities.walls = [];
        entities.drops.forEach(x=>scene.remove(x)); entities.drops = [];
        entities.trees.forEach(x=>scene.remove(x)); entities.trees = [];
        
        for(let i=0; i<20; i++) spawnTree();

        isRunning = true;
        document.body.requestPointerLock();
    };

    function gameOver() {
        isRunning = false;
        document.exitPointerLock();
        document.getElementById('final-time').innerText = document.getElementById('timer').innerText;
        document.getElementById('death-menu').style.display = 'flex';
        
        // Check record
        const cur = clock.getElapsedTime() - player.timers.start;
        const best = parseFloat(localStorage.getItem('rec') || 0);
        if (cur > best) {
            localStorage.setItem('rec', cur);
            document.getElementById('record-val').innerText = document.getElementById('timer').innerText;
        }
    }

    window.addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });

    init();
  </script>
</body>
</html>